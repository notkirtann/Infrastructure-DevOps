# Docker for Developers - Part 2: Docker Basics

## Docker Images and Docker Containers

`Docker Images` are read-only templates that contain the application code, libraries, dependencies, and environment settings needed to run an application. They serve as the blueprint for creating Docker Containers.

`Docker Containers` are the running instances of Docker Images. They encapsulate the application and its environment, allowing it to run consistently across different systems. Containers are lightweight and share the host system's kernel, making them efficient in terms of resource usage.

### Docker Engine 
The `Docker Engine` is the core component of Docker that enables the building, shipping, and running of Docker containers. It consists of a server (a long-running daemon process), a REST API for interacting with the daemon, and a command-line interface (CLI) client. The Docker Engine is responsible for managing Docker images, containers, networks, and storage.

### Docker CLI
The `Docker Command-Line Interface (CLI)` is a tool that allows users to interact with the Docker Engine through command-line commands. It provides a way to manage Docker images, containers, networks, and volumes. Common Docker CLI commands include:
- `docker run -it <image_name>`: Run a Docker container interactively from a specified image.
- `docker build`: Build a Docker image from a Dockerfile.
- `docker run`: Create and start a Docker container from an image.
- `docker ps`: List running Docker containers.
- `docker images`: List available Docker images on the local system.
- `docker stop`: Stop a running Docker container.
- `docker rm`: Remove a Docker container.
- `docker rmi`: Remove a Docker image.

### Docker Hub
`Docker Hub` is a cloud-based registry service provided by Docker for storing and sharing Docker images. It allows developers to publish their Docker images, making them accessible to others. Docker Hub also provides features such as automated builds, webhooks, and integration with popular CI/CD tools.
Developers can search for and pull pre-built images from Docker Hub, which can save time and effort when setting up development environments.

### Docker Image cmds
-  **build**        Build an image from a Dockerfile
    - ex: `docker build -t my_image:latest .`
-  **history**      Show the history of an image
    - ex: `docker history <image_name>`
-  **import**       Import the contents from a tarball to create a filesystem image
    - ex: `docker import ubuntu_image.tar`
-  **inspect**      Display detailed information on one or more images
    - ex: `docker inspect <image_name>`
-  **load**         Load an image from a tar archive or STDIN
    - ex: `docker load -i ubuntu_image.tar`
-  **ls**           List images
    - ex: `docker images`
-  **prune**        Remove unused images
    - ex: `docker image prune`
-  **pull**         Download an image from a registry
    - ex: `docker pull ubuntu:latest`
-  **push**         Upload an image to a registry
    - ex: `docker push <username>/<repository>:<tag>`
-  **rm**           Remove one or more images
    - ex: `docker rmi <image_id>`
-  **save**         Save one or more images to a tar archive (streamed to STDOUT by default)
    - ex: `docker save -o ubuntu_image.tar ubuntu:latest`
-  **search**       Search the Docker Hub for images
    - ex: `docker search <image_name>`
-  **tag**           Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
    - ex: `docker tag <source_image> <target_image>`

### Docker Container cmds
-  **attach**       Attach local standard input, output, and error streams to a running container
    - ex: `docker attach <container_id>`
-  **commit**       Create a new image from a container's changes
    - ex: `docker commit <container_id> <new_image_name>`
-  **cp**           Copy files/folders between a container and the local filesystem
    - ex: `docker cp <container_id>:/path/to/file /local/path`
-  **create**       Create a new container
    - ex: `docker create <image_name>`
-  **diff**         Inspect changes to files or directories on a container's filesystem
    - ex: `docker diff <container_id>`
-  **exec**         Execute a command in a running container
    - ex: `docker exec -it <container_id> /bin/bash`
-  **export**       Export a container's filesystem as a tar archive
    - ex: `docker export <container_id> > container.tar`
-  **inspect**      Display detailed information on one or more containers
    -   ex: `docker inspect <container_id>`
-  **kill**         Kill one or more running containers
    - ex: `docker kill <container_id>`
-  **logs**         Fetch the logs of a container
    - ex: `docker logs <container_id>`
-  **ls**           List containers
    - ex: `docker ps -a`
-  **pause**        Pause all processes within one or more containers
    - ex: `docker pause <container_id>`
-  **por**          List port mappings or a specific mapping for the container
    - ex: `docker port <container_id>`
-  **prune**        Remove all stopped containers
    - ex: `docker container prune`
-  **rename**       Rename a container
    - ex: `docker rename <old_name> <new_name>`
-  **restart**      Restart one or more containers
    - ex: `docker restart <container_id>`
-  **rm**           Remove one or more containers
    - ex: `docker rm <container_id>`
-  **run**          Create and run a new container from an image
    - ex: `docker run -it <image_name>`
-  **start**        Start one or more stopped containers
    - ex: `docker start <container_id>`
-  **stats**        Display a live stream of container(s) resource usage statistics
    - ex: `docker stats <container_id>`
-  **stop**         Stop one or more running containers
    - ex: `docker stop <container_id>`
-  **top**          Display the running processes of a container
    - ex: `docker top <container_id>`
-  **unpause**      Unpause all processes within one or more containers
    - ex: `docker unpause <container_id>`
-  **update**       Update configuration of one or more containers
    - ex: `docker update --cpu-shares 512 <container_id>`
-  **wait**         Block until one or more containers stop, then print their exit codes
    - ex: `docker wait <container_id>`

## Dockerfile Basics
A `Dockerfile` is a text file that contains a set of instructions for building a Docker image. It defines the base image, application code, dependencies, environment variables, and commands to run when the container starts. Here are some common instructions used in a Dockerfile:
- `FROM`: Specifies the base image for the Docker image.
- `COPY`: Copies files or directories from the host system to the Docker image.
- `RUN`: Executes commands in the Docker image during the build process.
- `CMD`: Specifies the command to run when the container starts.
- `EXPOSE`: Informs Docker that the container will listen on the specified network ports at runtime.
- `ENV`: Sets environment variables in the Docker image.
- `WORKDIR`: Sets the working directory for subsequent instructions in the Dockerfile.

### Example Dockerfile
1. Dockerfile 
```Dockerfile
# this i our base img
FROM ubuntu

# installing nodejs and npm
RUN apt-get update
RUN apt install -y curl
RUN curl -sL https://deb.nodesource.com/setup_25.x -o /tmp/nodesource_setup.sh
RUN bash /tmp/nodesource_setup.sh
RUN apt install -y nodejs

WORKDIR /home/app

# copying source code file to docker img
COPY index.ts /home/app-1/index.ts
COPY package.json /home/app-1/package.json
COPY package-lock.json /home/app-1/package-lock.json
# installing dependencies
RUN npm install
# cmd to run app when container starts
CMD ["node", "index.ts"]
```
2. dockerfile using node image
```Dockerfile
FROM node:22.22.0-alpine3.23

WORKDIR /home/app-1

# copying source code file to docker img
COPY index.ts /home/app-1/index.ts
COPY package.json /home/app-1/package.json
COPY package-lock.json /home/app-1/package-lock.json
# installing dependencies
RUN npm install
# cmd to run app when container starts
CMD ["node", "index.ts"]
```
3. best practices for writing dockerfile
- Use a small base image to reduce the size of the final image (e.g., use `alpine` versions of images).
- Minimize the number of layers by combining multiple commands into a single `RUN` instruction where possible.
- Leverage Docker's build cache by ordering instructions from least to most frequently changing.
- Use `.dockerignore` file to exclude unnecessary files and directories from the build context.
- Specify exact versions of dependencies to ensure consistent builds.
- Use multi-stage builds to separate the build environment from the runtime environment, reducing the final image size.
- Keep sensitive information out of the Dockerfile by using environment variables or Docker secrets.

4. .dockerignore file
```Dockerfile
FROM node:22.22.0-alpine3.23

WORKDIR /home/app-1/src

COPY package*.json ./ 
# Copy only package files first to leverage caching, package*.json will copy both package.json and package-lock.json

RUN npm install

COPY index.ts index.ts

CMD ["node", "index.ts"]
```
Explanation: Here, we set the working directory to `/home/app-1/src` and copy only the necessary files for installing dependencies first. This allows Docker to cache the `npm install` layer, so if only the source code changes, we don't have to reinstall dependencies again, speeding up the build process.
